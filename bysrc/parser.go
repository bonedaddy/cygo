package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/build"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"gopp"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"reflect"
	"strings"

	"golang.org/x/tools/go/ast/astutil"

	"github.com/thoas/go-funk"
	"github.com/twmb/algoimpl/go/graph"
)

type ParserContext struct {
	path          string
	wkdir         string // for cgo
	pkgrename     string
	builtin_psctx *ParserContext

	fset     *token.FileSet
	pkgs     map[string]*ast.Package
	files    []*ast.File
	typkgs   *types.Package
	conf     types.Config
	chkerrs  []error
	info     types.Info
	cursors  map[ast.Node]*astutil.Cursor
	grstargs map[string]bool // goroutines packed arguments structure

	typeDeclsm    map[string]*ast.TypeSpec
	typeDeclsv    []*ast.TypeSpec
	funcDeclsm    map[string]*ast.FuncDecl
	funcDeclsv    []*ast.FuncDecl
	funcdeclNodes map[string]graph.Node
	initFuncs     []*ast.FuncDecl
	functypes     map[ast.Expr]string // *ast.FuncType => tmptyname

	cpr       *cparser1
	fcpkg     *types.Package           // fakec package, generated by this Object
	csymbols  map[ast.Node]ast.ObjKind // TODO use slice to keep order
	ctypes    map[ast.Expr]types.Type
	cidents   map[*ast.Ident]types.TypeAndValue // 传播其他位置引用c类型返回值的变量的类型
	tmpvars   map[ast.Stmt][]ast.Node           // => value node
	gostmts   []*ast.GoStmt
	chanops   []ast.Expr // *ast.SendStmt
	closures  []*ast.FuncLit
	multirets []*ast.FuncDecl
	defers    []*ast.DeferStmt
	globvars  []ast.Node            // => ValueSpec node
	kvpairs   map[ast.Node]ast.Node // left <=> value

	gb       *graph.Graph // decl depgraph in one package
	bdpkgs   *build.Package
	ccode    string
	fcdefscc string // fake C defs content
}

func NewParserContext(path string, pkgrename string, builtin_psctx *ParserContext) *ParserContext {
	this := &ParserContext{}
	this.path = path
	this.pkgrename = pkgrename
	this.builtin_psctx = builtin_psctx

	this.info.Types = make(map[ast.Expr]types.TypeAndValue)
	this.info.Defs = make(map[*ast.Ident]types.Object)
	this.info.Uses = make(map[*ast.Ident]types.Object)
	this.info.Scopes = make(map[ast.Node]*types.Scope)
	this.info.Implicits = make(map[ast.Node]types.Object)

	this.cursors = make(map[ast.Node]*astutil.Cursor)
	this.grstargs = make(map[string]bool)
	this.typeDeclsm = make(map[string]*ast.TypeSpec)
	this.funcDeclsm = make(map[string]*ast.FuncDecl)
	this.funcdeclNodes = make(map[string]graph.Node)
	this.initFuncs = make([]*ast.FuncDecl, 0)
	this.functypes = make(map[ast.Expr]string)

	this.fcpkg = types.NewPackage("C", "C")
	this.gb = graph.New(graph.Directed)

	return this
}
func (this *ParserContext) Init() error {
	this.init_extra_builtin_types()
	return this.Init_no_cgocmd()
	// return this.Init_explict_cgo()
}
func (this *ParserContext) init_extra_builtin_types() {
	// too late call here, so need modify go/types/ files directly
	// types.HackExtraBuiltin() // file: go/types/myhack.go
	// tybno := types.UntypedNil
	// tybinfo := types.IsUntyped
	// vptrty := types.Basic{tybno << 1, tybinfo << 1, "voidptr"}
	// types.Typ = append(types.Typ, vptrty)
}

func (this *ParserContext) Init_no_cgocmd() error {

	bdpkgs, err := build.ImportDir(this.path, build.ImportComment)
	gopp.ErrPrint(err)
	this.bdpkgs = bdpkgs
	if len(bdpkgs.InvalidGoFiles) > 0 {
		log.Fatalln("Have InvalidGoFiles", bdpkgs.InvalidGoFiles)
	}
	log.Println(this.path, bdpkgs.Name, bdpkgs.GoFiles, bdpkgs.TestGoFiles,
		bdpkgs.CgoFiles, bdpkgs.CFiles, bdpkgs.CXXFiles)

	// parser step 2, got ast/types
	this.fset = token.NewFileSet()
	pkgs, err := parser.ParseDir(this.fset, this.path, this.dirFilter, 0|parser.AllErrors|parser.ParseComments)
	gopp.ErrPrint(err)
	this.pkgs = pkgs
	gopp.Assert(len(pkgs) == 1, "wtttt", len(pkgs), this.path)
	this.ccode = this.pickCCode()

	cp1 := newcparser1(bdpkgs.Name)
	cp1.parsestr(this.ccode)
	this.cpr = cp1

	this.walkpass_valid_files()
	this.walkpass_flat_cursors()
	this.walkpass_csymbols()
	// this.walkpass_prefill_ctypes() // before types.Config.Check
	this.walkpass_fill_fakecpkg()   // before types.Config.Check
	this.walkpass_fill_builtinpkg() // before types.Config.Check

	this.walkpass_check() // semantics check
	if this.chkerrs != nil {
		os.Exit(-1)
	}
	// this.walkpass_resolve_ctypes()
	// this.walkpass_flat_cursors() // move move previous
	// this.walkpass_clean_cgodecl()
	this.walkpass_flat_cursors()
	this.walkpass_func_deps()
	log.Println("pkgs", this.typkgs.Name(), "types:", len(this.info.Types),
		"typedefs", len(this.typeDeclsm), "funcdefs", len(this.funcDeclsm),
		"fakecdefs", len(this.csymbols))

	this.walkpass_tmpvars()
	this.walkpass_kvpairs()
	this.walkpass_gostmt()
	this.walkpass_chan_send_recv()
	this.walkpass_closures()
	this.walkpass_multiret()
	this.walkpass_defers()
	this.walkpass_globvars()
	this.walkpass_functypes()

	return err
}
func (pc *ParserContext) pkgimperror(err error) {
	if err == nil {
		return
	}
	if strings.Contains(err.Error(), "declared but not used") ||
		strings.Contains(err.Error(), "not exported by package C") ||
		strings.Contains(err.Error(), "too many arguments") ||
		strings.Contains(err.Error(), "not exported by package") ||
		(strings.Contains(err.Error(), "cannot convert") &&
			(strings.Contains(err.Error(), "__ctype "))) {
		// log.Println(err)
	} else {
		log.Println(err)
		// must stop error
		if strings.Contains(err.Error(), "could not import") ||
			strings.Contains(err.Error(), "no result values expected") ||
			strings.Contains(err.Error(), "missing return") {
			pc.chkerrs = append(pc.chkerrs, err)
		}
	}
}
func (this *ParserContext) Init_explict_cgo() error {
	bdpkgs, err := build.ImportDir(this.path, build.ImportComment)
	gopp.ErrPrint(err)
	this.bdpkgs = bdpkgs
	if len(bdpkgs.InvalidGoFiles) > 0 {
		log.Fatalln("Have InvalidGoFiles", bdpkgs.InvalidGoFiles)
	}
	// use go-clang to resolve c function signature
	// extract c code from bdpkgs.CgoFiles
	// parser step 1, got raw cgo c code
	{
		this.fset = token.NewFileSet()

		pkgs, err := parser.ParseDir(this.fset, this.path, this.dirFilter, 0|parser.AllErrors|parser.ParseComments)
		gopp.ErrPrint(err)
		this.pkgs = pkgs
		this.ccode = this.pickCCode()
	}

	this.walkpass_csymbols()
	this.walkpass_cgo_processor()
	// replace codebase dir
	this.path, this.wkdir = this.wkdir, this.path
	bdpkgs, err = build.ImportDir(this.path, build.ImportComment)
	gopp.ErrPrint(err)
	this.bdpkgs = bdpkgs
	if len(bdpkgs.InvalidGoFiles) > 0 {
		log.Fatalln("Have InvalidGoFiles", bdpkgs.InvalidGoFiles)
	}
	log.Println(bdpkgs.GoFiles)

	// parser step 2, got ast/types
	this.fset = token.NewFileSet()
	pkgs, err := parser.ParseDir(this.fset, this.path, this.dirFilter, 0|parser.AllErrors|parser.ParseComments)
	gopp.ErrPrint(err)
	this.pkgs = pkgs

	// this.ccode = this.pickCCode()
	this.walkpass_valid_files()

	this.walkpass_check()

	this.walkpass_clean_cgodecl()
	this.walkpass_resolve_ctypes_bycgo()
	this.walkpass_flat_cursors()
	this.walkpass_func_deps()
	log.Println("pkgs", this.typkgs.Name(), "types:", len(this.info.Types),
		"typedefs", len(this.typeDeclsm), "funcdefs", len(this.funcDeclsm))

	this.walkpass_tmpvars()
	this.walkpass_kvpairs()
	this.walkpass_gostmt()
	this.walkpass_chan_send_recv()
	this.walkpass_closures()
	this.walkpass_multiret()
	this.walkpass_defers()
	this.walkpass_globvars()

	return err
}

// cgo preprocessor
func (pc *ParserContext) walkpass_cgo_processor() {
	pc.wkdir = "_obj"
	{
		err := os.RemoveAll(pc.wkdir + "/")
		gopp.ErrPrint(err, pc.wkdir)
		os.Mkdir(pc.wkdir, 0755)
	}
	goexe, err := exec.LookPath("go")
	gopp.ErrPrint(err)
	cmdfld := []string{goexe, "tool", "cgo", "-objdir", pc.wkdir}
	bdpkgs := pc.bdpkgs
	for _, cgofile := range bdpkgs.CgoFiles {
		cgofile = bdpkgs.Dir + "/" + cgofile
		cmdfld = append(cmdfld, cgofile)
	}
	log.Println(cmdfld)
	if len(bdpkgs.CgoFiles) > 0 {
		cmdo := exec.Command(cmdfld[0], cmdfld[1:]...)
		allout, err := cmdo.CombinedOutput()
		gopp.ErrPrint(err, cmdfld)
		allout = bytes.TrimSpace(allout)
		if len(allout) > 0 {
			log.Println(string(allout))
		}
		if err != nil {
			os.Exit(-1)
		}
	}

	// copy orignal source to wkdir
	// remove cgofile from wkdir
	files, err := filepath.Glob(bdpkgs.Dir + "/*")
	gopp.ErrPrint(err)
	for _, file := range files {
		if funk.Contains(bdpkgs.CgoFiles, filepath.Base(file)) {
			continue
		}
		err = gopp.CopyFile(file, pc.wkdir+"/"+filepath.Base(file))
		gopp.ErrPrint(err, file)
	}
	os.Rename(pc.wkdir+"/_cgo_gotypes.go", pc.wkdir+"/cxuse_cgo_gotypes.go")
}

func (pc *ParserContext) walkpass_check() {
	pc.conf.DisableUnusedImportCheck = true
	pc.conf.Error = pc.pkgimperror
	pc.conf.FakeImportC = true
	pc.conf.FakeImportC = false
	pc.conf.Importer = &mypkgimporter{pc.fcpkg}

	files := pc.files
	// files = append(files, pc.fakecfile())
	var err error
	pc.typkgs, err = pc.conf.Check(pc.path, pc.fset, files, &pc.info)
	pc.pkgimperror(err)
	log.Println("pkgcomplete", pc.typkgs.Name(), pc.typkgs.Complete())
}

func (this *ParserContext) nameFilter2(filename string, files []string) bool {
	for _, okfile := range files {
		if filename == okfile {
			return true // keep
		}
	}
	return false
}
func (this *ParserContext) nameFilter(filename string) bool {
	if this.nameFilter2(filename, this.bdpkgs.GoFiles) {
		return true
	}
	if this.nameFilter2(filename, this.bdpkgs.CgoFiles) {
		return true
	}
	return false
}
func (this *ParserContext) dirFilter(f os.FileInfo) bool {
	return this.nameFilter(f.Name())
}

type mypkgimporter struct {
	fcpkg *types.Package
}

func (this *mypkgimporter) Import(path string) (pkgo *types.Package, err error) {
	log.Println("importing ...", path)
	if path == "C" {
		return this.fcpkg, nil
	}
	if true {
		// go 1.12
		fset := token.NewFileSet()
		pkgo, err = importer.ForCompiler(fset, "source", nil).Import(path)
	} else {
		pkgo, err = importer.Default().Import(path)
	}
	gopp.ErrPrint(err, path)
	return pkgo, err
}

func trimgopath(filename string) string {
	gopaths := gopp.Gopaths()

	for _, pfx := range gopaths {
		if strings.HasPrefix(filename, pfx) {
			return filename[len(pfx)+5:]
		}
	}
	return filename
}
func exprpos(pc *ParserContext, e ast.Node) token.Position {
	if e == nil {
		return token.Position{}
	}
	poso := pc.fset.Position(e.Pos())
	poso.Filename = trimgopath(poso.Filename)
	return poso
}

func (this *ParserContext) pickCCode() string {
	rawcode := this.pickCCode2()
	lines := strings.Split(rawcode, "\n")
	rawcode = ""
	for _, line := range lines {
		if !strings.HasPrefix(line, "#cgo ") {
			rawcode += line + "\n"
		} else {
			rawcode += "// " + line + "\n"
		}
	}
	// log.Println("got c code", rawcode)
	return rawcode
}
func (this *ParserContext) pickCCode2() string {
	ccode := ""
	for _, f := range this.bdpkgs.CgoFiles {
		var fo *ast.File = this.findFileobj(f)
		ccode += this.pickCCode3(fo)
	}
	return ccode
}
func (this *ParserContext) pickCCode3(fo *ast.File) string {
	for idx, cmto := range fo.Comments {
		// isimpcblock(cmto)???
		for idx2, impo := range fo.Imports {
			gopp.G_USED(idx, idx2)
			if impo.Pos()-token.Pos(len("\nimport ")) == cmto.End() {
				// log.Println("got c code", cmto.Text())
				return cmto.Text()
			}
		}
	}
	return ""
}
func (this *ParserContext) findFileobj(fbname string) *ast.File {
	for _, pkgo := range this.pkgs {
		for filename, fileo := range pkgo.Files {
			name := filepath.Base(filename)
			if name == fbname {
				return fileo
			}
		}
	}
	return nil
}

func (pc *ParserContext) walkpass_resolve_ctypes_bycgo() {
	pkgs := pc.pkgs

	ctypes := map[ast.Expr]types.Type{}
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case ast.Expr:
				csty := pc.info.TypeOf(te)
				if csty != nil && !isinvalidty2(csty) {
				} else {
					log.Println("unfixty", te, reftyof(te), csty)
				}
				if strings.Contains(exprstr(te), "_Ctype_") ||
					strings.Contains(exprstr(te), "_Cfunc_") {
					log.Println("cgo ", reftyof(te), exprstr(te), csty)
				}
			case *ast.Ident:
			}
			return true
		}, func(c *astutil.Cursor) bool {
			return true
		})
	}
	pc.ctypes = ctypes
}

func astcs_next(c *astutil.Cursor) *astutil.Cursor {
	return nil
}
func astcs_prev(c *astutil.Cursor) *astutil.Cursor {
	return nil
}
func astcs_upper(c *astutil.Cursor) *astutil.Cursor {
	return nil
}

func (pc *ParserContext) walkpass_csymbols() {
	pkgs := pc.pkgs

	cfuncs := map[ast.Node]ast.ObjKind{}
	cnodes := map[ast.Node]ast.ObjKind{}
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.SelectorExpr:
				if iscident(te.X) {
					// log.Println("got111", te.X, te.Sel, c.Index())
					// log.Println(c.Parent(), reflect.TypeOf(c.Parent()))
					cnodes[c.Node()] = ast.Var
				}
			case *ast.CallExpr:
				fo := te.Fun
				if fe, ok := fo.(*ast.SelectorExpr); ok {
					if iscident(fe.X) {
						cfuncs[c.Node()] = ast.Fun
						// log.Println("got222", exprstr(fe.X), fe.X, fe.Sel)
					}
				}
			case *ast.ValueSpec:
				// in const
				for i := 0; i < len(te.Names); i++ {
					if len(te.Values) <= i {
						break
					}
					value := te.Values[i]
					if se, ok := value.(*ast.SelectorExpr); ok {
						if iscident(se.X) {
							cnodes[se] = ast.Var
						}
					}
				}
			}
			return true
		}, func(c *astutil.Cursor) bool {
			return true
		})
	}

	res := map[ast.Node]ast.ObjKind{}
	seens := map[string]bool{}
	for nx, _ := range cnodes {
		n := nx.(*ast.SelectorExpr)
		if _, exist := seens[n.Sel.Name]; exist {
			continue // dedup
		}
		seens[n.Sel.Name] = true
		found := false
		for fx, _ := range cfuncs {
			f := fx.(*ast.CallExpr)
			sel := f.Fun.(*ast.SelectorExpr)
			if sel.Sel.Name == n.Sel.Name {
				found = true
				res[f] = ast.Fun
				break
			}
		}
		if !found {
			res[nx] = ast.Var
		}
	}
	pc.csymbols = res
}

type csyminfo struct {
	idt      *ast.Ident
	varo     *types.Var
	funo     *types.Func
	isfunc   bool
	isconst  bool
	isstruct bool
	isfield  bool
	istype   bool
}

func newcsyminfo(idt *ast.Ident, varo *types.Var) *csyminfo {
	csi := &csyminfo{}
	csi.idt = idt
	csi.varo = varo
	return csi
}

// before types.Config.Check
func (pc *ParserContext) walkpass_fill_fakecpkg() {
	pkgs := pc.pkgs

	fcpkg := pc.fcpkg
	fcpkg.MarkComplete()
	scope := fcpkg.Scope()

	tmpidts := map[*ast.Ident]*types.Var{}
	tmpidts2 := map[*ast.Ident]*csyminfo{}
	inconst := false
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.GenDecl:
				if te.Tok == token.CONST {
					inconst = true
				} else {
					inconst = false
				}
			case *ast.SelectorExpr:
				if iscident(te.X) {
					pn := c.Parent()
					var atye ast.Expr
					if fe, ok := pn.(*ast.Field); ok {
						atye = fe.Type
					}
					istype := atye == te // 是否是在type的位置上
					// log.Println("got111", te.X, te.Sel, c.Index(), inconst, reftyof(pn), atye, reftyof(atye), atye == te, istype)
					v1 := fakecvar(te.Sel, fcpkg)
					// scope.Insert(v1)
					tmpidts[te.Sel] = v1
					csi := newcsyminfo(te.Sel, v1)
					csi.istype = istype
					csi.isconst = inconst
					tmpidts2[te.Sel] = csi

					// 怎么获对应的变量名
					valspx := upfind_func(pc, c, 0, func(c2 *astutil.Cursor) bool {
						_, ok := c2.Node().(*ast.ValueSpec)
						if !ok {
							_, ok = c2.Node().(*ast.AssignStmt)
						}
						return ok
					})
					if valspx == nil { // 不在赋值或者声明语句
						break
					}
					var ales []ast.Expr
					switch valspe := valspx.(type) {
					case *ast.ValueSpec:
						for idx, _ := range valspe.Names {
							ales = append(ales, valspe.Names[idx])
						}
					case *ast.AssignStmt:
						for idx, _ := range valspe.Lhs {
							ales = append(ales, valspe.Lhs[idx])
						}
					}
					blkst := upfind_blockstmt(pc, c, 0)
					if blkst == nil {
						break
					}
					for idx, ale := range ales {
						if _, ok := ale.(*ast.Ident); !ok {
							continue
						}

						used := find_use_ident(pc, blkst, ale.(*ast.Ident))
						log.Println(idx, used, len(blkst.List))
						for _, selex := range used {
							sele := selex.(*ast.SelectorExpr)
							log.Println(idx, sele, exprstr(sele), te.Sel)
							fldidt := ast.NewIdent(te.Sel.Name + "." + sele.Sel.Name)
							pc.csymbols[fldidt] = ast.Var
							csi := newcsyminfo(fldidt, nil)
							csi.isfield = true
							tmpidts2[fldidt] = csi
						}
					}
				}
			case *ast.CallExpr:
				fo := te.Fun
				if fe, ok := fo.(*ast.SelectorExpr); ok {
					if iscident(fe.X) {
						// log.Println("got222", exprstr(fe.X), fe.X, fe.Sel)
						f1 := fakecfunc(fe.Sel, fcpkg)
						scope.Insert(f1)
						tystr, tyobj := pc.cpr.symtype(fe.Sel.Name)
						if tyobj == nil {
							log.Println(pkg.Name, "not found ctype", fe.Sel, tystr)
						} else {
							selidt := ast.NewIdent(fe.Sel.Name + "_ofcp")
							f2 := fakecfunc2(selidt, fcpkg, tyobj)
							scope.Insert(f2)
						}
						csi := newcsyminfo(fe.Sel, nil)
						csi.isfunc = true
						csi.funo = f1
						tmpidts2[fe.Sel] = csi
					}
				}
			case *ast.ValueSpec:
				// in const
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.GenDecl:
				if te.Tok == token.CONST {
					inconst = false
				}
			}
			return true
		})
	}
	{
		idt := ast.NewIdent(fmt.Sprintf("demo_const_of_%s", pc.bdpkgs.Name))
		cst1 := fakecconst(idt, fcpkg)
		scope.Insert(cst1)
	}
	{
		idt := ast.NewIdent(fmt.Sprintf("demo_var_of_%s", pc.bdpkgs.Name))
		cst1 := fakecvar(idt, fcpkg)
		scope.Insert(cst1)
	}
	{
		idt := ast.NewIdent(fmt.Sprintf("demo_func_of_%s", pc.bdpkgs.Name))
		cst1 := fakecfunc(idt, fcpkg)
		scope.Insert(cst1)
	}
	log.Println(len(scope.Names()), scope.Names())
	for idt, varx := range tmpidts {
		idtname := idt.Name
		if obj := scope.Lookup(idt.Name); obj != nil {
			continue
		}
		csi := tmpidts2[idt]
		if strings.HasPrefix(idtname, "struct_") {
		} else if csi != nil && csi.istype {
			// log.Println("gen fakectype", csi.idt)
			st1 := types.Typ[types.Voidptr]
			// st1 := types.Typ[types.UnsafePointer]
			// st1 := types.NewCtype(idtname + "__ctype")
			stobj := types.NewTypeName(token.NoPos, fcpkg, idtname, nil)
			stobj2 := types.NewNamed(stobj, st1, nil)
			_ = stobj
			scope.Insert(stobj2.Obj())
		} else {
			scope.Insert(varx)
			idtobj := ast.NewIdent(varx.Name() + "_asconst")
			cst1 := fakecconst(idtobj, fcpkg)
			scope.Insert(cst1)
			ctystr, ctyobj := pc.cpr.symtype(idtname)
			if ctyobj == nil {
				log.Println(pc.bdpkgs.Name, idtname, ctystr, ctyobj)
			} else {
				idtobj := ast.NewIdent(varx.Name() + "_ofcp")
				cst1 := types.NewConst(token.NoPos, fcpkg, idtobj.Name, ctyobj, nil)
				scope.Insert(cst1)
			}
		}
	}
	log.Println(len(scope.Names()), scope.Names())
	if filepath.Base(pc.path) == "unsafe" {
		return
	}
	{
		f1 := types.NewField(token.NoPos, fcpkg, "field111", types.NewCtype("test111"), false)
		st1 := types.NewStruct([]*types.Var{f1}, nil)
		// st2 := types.NewCtype("struct_hhhhhh")
		stobj := types.NewTypeName(token.NoPos, fcpkg, "struct_lllll", nil)
		stobj2 := types.NewNamed(stobj, st1, nil)
		_ = stobj
		scope.Insert(stobj2.Obj())
	}
	{
		st1 := types.Typ[types.Voidptr]
		stobj := types.NewTypeName(token.NoPos, fcpkg, "socklenttt", nil)
		stobj2 := types.NewNamed(stobj, st1, nil)
		_ = stobj
		scope.Insert(stobj2.Obj())
	}
	// gen struct type, with field that used
	{
		var cstructs = map[string][]string{} // struct name => field name
		for nx, _ := range pc.csymbols {
			// log.Println(nx, reftyof(nx))
			switch ne := nx.(type) {
			case *ast.Ident:
				segs := strings.Split(ne.Name, ".")
				if funk.Contains(cstructs[segs[0]], segs[1]) {
					break
				}
				cstructs[segs[0]] = append(cstructs[segs[0]], segs[1])
			case *ast.SelectorExpr:
				// C.struct_timeval
				selname := ne.Sel.Name
				if strings.HasPrefix(selname, "struct_") {
					if _, ok := cstructs[selname]; !ok {
						cstructs[selname] = nil
					}
				}
			}
		}
		log.Println("fakec structs", cstructs)
		for stname, fldnames := range cstructs {
			fldvars := []*types.Var{}
			for _, fldname := range fldnames {
				tyname := fmt.Sprintf("%s__%s__ctype", stname, fldname)
				fldtyp := types.NewCtype(tyname)
				// fvar := types.NewField(token.NoPos, fcpkg, fldname, fldtyp, false)
				tpkg := fcpkg
				for name, _ := range pkgs {
					tpkg = types.NewPackage(pc.path, name)
					break
				}
				// var 在建在当前包中!!!??? make go/types.LookupFieldOrMethod happy
				fvar := types.NewVar(token.NoPos, tpkg, fldname, fldtyp)
				fldvars = append(fldvars, fvar)
			}
			st1 := types.NewStruct(fldvars, nil)
			// keep NewTypeName's type arg nil, so next step get a valid struct type
			stobj := types.NewTypeName(token.NoPos, fcpkg, stname, nil)
			stobj2 := types.NewNamed(stobj, st1, nil)
			scope.Insert(stobj2.Obj())
		}
	}
	buf := bytes.NewBuffer(nil)
	buf.WriteString(pc.path + "\n")
	scope.WriteTo(buf, 1, true)
	pc.fcdefscc = "// " + strings.ReplaceAll(string(buf.Bytes()), "\n", "\n// ")
}

// before types.Config.Check
func (pc *ParserContext) walkpass_fill_builtinpkg() {
	if pc.builtin_psctx == nil {
		return
	}
	pkgs := pc.pkgs
	bipc := pc.builtin_psctx
	bidefs := map[string]bool{}
	for idt, obj := range bipc.info.Defs {
		if obj == nil {
			continue // package ident
		}
		bidefs[idt.Name] = true
	}

	for _, pkg := range pkgs {
		for _, fio := range pkg.Files {
			var gendecl *ast.GenDecl
			for _, d := range fio.Decls {
				switch dd := d.(type) {
				case *ast.GenDecl:
					gendecl = dd
				}
			}
			if gendecl == nil {
				gendecl = &ast.GenDecl{}
				fio.Decls = append(fio.Decls, gendecl)
			}

			iSpec := newimpspec("cxrt/xgo/builtin", "")
			gendecl.Specs = append(gendecl.Specs, iSpec)
			ast.SortImports(pc.fset, fio)
		}

		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.Ident:
				obj := te.Obj
				if obj != nil {
					break
				}
				if te.Name == pkg.Name {
					break
				}
				_, inbi := bidefs[te.Name]
				if !inbi {
					break
				}
				if _, ok := c.Parent().(*ast.SelectorExpr); ok {
					break
				}
				if _, ok := c.Parent().(*ast.Ident); ok {
					break
				}
				if _, ok := c.Parent().(*ast.FuncDecl); ok {
					break
				}
				if funk.Contains([]string{"len", "cap"}, te.Name) {
					break
				}
				log.Println(te, obj == nil, obj, reftyof(c.Parent()))
				sele := &ast.SelectorExpr{}
				sidt := newIdent("builtin")
				sele.X = sidt
				sele.Sel = te
				c.Replace(sele)

				// 把builtin的包ident添加上包前缀
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}

func (pc *ParserContext) walkpass_resolve_ctypes() {
	gopp.Assert(1 == 2, "waitdep")
	pc.walkpass_resolve_ctypes1()
	for e, t := range pc.ctypes {
		log.Println(exprstr(e), t)
	}
	pc.walkpass_resolve_ctypes2()
	pc.walkpass_resolve_ctypes3()
}
func (pc *ParserContext) walkpass_resolve_ctypes1() {
	gopp.Assert(1 == 2, "waitdep")
	pkgs := pc.pkgs

	ctypes := map[ast.Expr]types.Type{}
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case ast.Expr:
				csty := pc.info.TypeOf(te)
				if csty != nil && !isinvalidty2(csty) {
					break
				}

				switch se := te.(type) {
				case *ast.SelectorExpr:
					if iscsel(se) {
						caty := &canytype{}
						caty.name = se.Sel.Name + "__ctype"
						tyandval := types.TypeAndValue{} //caty, nil}
						tyandval.Type = caty
						pc.info.Types[se] = tyandval
						pc.info.Types[se.Sel] = tyandval
						ctypes[se] = caty
						pn := c.Parent()
						// log.Println(reftyof(pn))
						switch pe := pn.(type) {
						case *ast.CallExpr:
							pc.info.Types[pe] = tyandval
							ctypes[pe] = caty
							// pe2 := pc.cursors[pe].Parent()
							// if _, ok := pe2.(*ast.StarExpr); ok {
							// pc.info.Types[pe2] =
							//}
						}
						// ctypes[c.Parent().(ast.Expr)] = caty
						// log.Println("fix some", te, reftyof(te), csty, ",", caty)
					} else {
						log.Println("fixty", te, reftyof(te), csty)
					}
				default:
					log.Println(te, reftyof(te), csty)
				}
			}
			return true
		}, func(c *astutil.Cursor) bool {
			return true
		})
	}
	pc.ctypes = ctypes
}
func (pc *ParserContext) walkpass_resolve_ctypes2() {
	gopp.Assert(1 == 2, "waitdep")
	pkgs := pc.pkgs

	// 需要一个带scope 的 AST 遍历
	pc.cidents = map[*ast.Ident]types.TypeAndValue{}
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.AssignStmt:
				for idx, le := range te.Lhs {
					csty := pc.info.TypeOf(le)
					if csty != nil && !isinvalidty2(csty) {
						break
					}
					re := te.Rhs[idx]
					csty2 := pc.info.TypeOf(re)
					if csty2 != nil && !isinvalidty2(csty2) {
						log.Println(idx, "canfixty", le, reftyof(le), csty2)
						tyandval := types.TypeAndValue{} //caty, nil}
						tyandval.Type = csty2
						pc.info.Types[le] = tyandval
						pc.ctypes[le] = tyandval.Type
						if idt, ok := le.(*ast.Ident); ok {
							pc.cidents[idt] = tyandval
						}
					} else {
						csty3 := pc.ctypes[re]
						if csty3 != nil {
							log.Println(idx, "canfixty", le, reftyof(le), csty2)
							tyandval := types.TypeAndValue{Type: csty2} //caty, nil}
							pc.info.Types[le] = tyandval
							pc.ctypes[le] = tyandval.Type
							if idt, ok := le.(*ast.Ident); ok {
								pc.cidents[idt] = tyandval
							}
						} else {
							log.Println(idx, "cannot fixty", le, reftyof(le), csty2, csty3, exprstr(re), reftyof(re))
						}
					}
				}
			case *ast.ValueSpec:
				for _, name := range te.Names {
					csty := pc.info.TypeOf(name)
					if csty != nil && !isinvalidty2(csty) {
						break
					}
					log.Println("untyval", reftyof(name), exprstr(name))
				}
			case *ast.Ident:
				if te.Name == "C" {
					break
				}
				csty := pc.info.TypeOf(te)
				if csty != nil && !isinvalidty2(csty) {
					break
				}
				incidt := pc.cidents[te] // 名字相同，但实例不同的ident无法匹配
				for idt, idty := range pc.cidents {
					if idt.Name == te.Name {
						if te.Obj != nil && te.Obj == idt.Obj {
							incidt = idty
						}
						// log.Println("same name ident", idty, idt == te, incidt, te.Obj == idt.Obj)
					}
				}
				if incidt.Type != nil {
					pc.info.Types[te] = incidt
					pc.ctypes[te] = incidt.Type
					log.Println("fixtyidt", reftyof(te), exprstr(te), incidt, len(pc.cidents))
				} else {
					log.Println("untyidt", reftyof(te), exprstr(te), incidt, len(pc.cidents))
				}
			case *ast.BinaryExpr:
				csty := pc.info.TypeOf(te)
				if csty != nil && !isinvalidty2(csty) {
					break
				}
				tyx := pc.info.TypeOf(te.X)
				tyy := pc.info.TypeOf(te.Y)
				var tyres types.Type
				if isinvalidty2(tyx) || isinvalidty2(tyy) {
					log.Println("not possible?")
				}
				if !isinvalidty2(tyx) {
					tyres = tyx
				}
				if !isinvalidty2(tyy) {
					tyres = tyy
				}
				pc.info.Types[te] = types.TypeAndValue{Type: tyres}
				pc.ctypes[te] = tyres
				if isinvalidty2(tyx) {
					pc.info.Types[te.X] = types.TypeAndValue{Type: tyres}
					pc.ctypes[te.X] = tyres
				}
				if isinvalidty2(tyy) {
					pc.info.Types[te.Y] = types.TypeAndValue{Type: tyres}
					pc.ctypes[te.Y] = tyres
				}

				log.Println("fixed untybinop", reftyof(te), exprstr(te), len(pc.cidents), tyx, tyy)

			case ast.Expr:
			}
			return true
		})
	}

}
func (pc *ParserContext) walkpass_resolve_ctypes3() {
	gopp.Assert(1 == 2, "waitdep")
	pkgs := pc.pkgs

	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case ast.Expr:
				csty := pc.info.TypeOf(te)
				if csty != nil && !isinvalidty2(csty) {
					break
				}
				log.Println("unresolvty", reftyof(te), exprstr(te))
			}
			return true
		})
	}

}

func (pc *ParserContext) walkpass_valid_files() {
	this := pc
	pkgs := pc.pkgs

	var files []*ast.File
	for _, pkg := range pkgs {
		for _, file := range pkg.Files {
			if strings.HasSuffix(file.Name.Name, "_test") {
				continue
			}
			files = append(files, file)
		}
	}
	this.files = files
}

func (pc *ParserContext) walkpass_func_deps() {
	pc.walkpass_func_deps1()
	pc.walkpass_func_deps2()
}
func (pc *ParserContext) walkpass_func_deps1() {
	this := pc
	pkgs := pc.pkgs

	pc.putFuncCallDependcy("main", "main_go")
	for _, pkg := range pkgs {
		var curfds []string // stack, current func decls
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.TypeSpec:
				// log.Println("typedef", t.Name.Name)
				this.typeDeclsm[te.Name.Name] = te
			case *ast.FuncDecl:
				if te.Recv != nil && te.Recv.NumFields() > 0 {
					varty := te.Recv.List[0].Type
					if ve, ok := varty.(*ast.StarExpr); ok {
						varty2 := ve.X
						tyname := varty2.(*ast.Ident).Name
						fnfullname := tyname + "_" + te.Name.Name
						this.funcDeclsm[fnfullname] = te
						curfds = append(curfds, fnfullname)
					} else if ve, ok := varty.(*ast.Ident); ok {
						tyname := ve.Name
						fnfullname := tyname + "_" + te.Name.Name
						this.funcDeclsm[fnfullname] = te
						curfds = append(curfds, fnfullname)
					} else {
						log.Println("todo", varty, reflect.TypeOf(te.Recv.List[0]))
					}
				} else {
					if te.Name.Name == "init" {
						this.initFuncs = append(this.initFuncs, te)
					}
					this.funcDeclsm[te.Name.Name] = te
					curfds = append(curfds, te.Name.Name)
				}
			case *ast.CallExpr:
				if len(curfds) == 0 { // global scope call
					switch be := te.Fun.(type) {
					case *ast.SelectorExpr:
						if iscsel(be.X) {
							break
						} else {
							log.Println("wtf", te, te.Fun, reflect.TypeOf(te.Fun))
						}
					default:
						log.Println("wtf", te, te.Fun, reflect.TypeOf(te.Fun))
					}
					// break
				} else {
					var curfd = curfds[len(curfds)-1]
					switch be := te.Fun.(type) {
					case *ast.Ident:
						this.putFuncCallDependcy(curfd, be.Name)
					case *ast.SelectorExpr:
						if iscsel(be.X) {
							break
						}
						varty := this.info.TypeOf(be.X)
						tyname := sign2rety(varty.String())
						tyname = strings.TrimRight(tyname, "*")
						fnfullname := tyname + "_" + be.Sel.Name
						this.putFuncCallDependcy(curfd, fnfullname)
					default:
						log.Println("todo", te.Fun, reflect.TypeOf(te.Fun))
					}
				}
			case *ast.Ident: // func name referenced
				if len(curfds) == 0 {
					break
				}
				var curfd = curfds[len(curfds)-1]
				varobj := this.info.ObjectOf(te)
				switch varobj.(type) {
				case *types.Func:
					this.putFuncCallDependcy(curfd, te.Name)
				}
			case *ast.ReturnStmt:
			case *ast.CompositeLit:
				if len(curfds) == 0 {
					log.Println("todo globvar", exprpos(pc, c.Node()))
					break
				}
				var curfd = curfds[len(curfds)-1]
				goty := pc.info.TypeOf(te.Type)
				for funame, fd := range pc.funcDeclsm {
					if fd.Recv.NumFields() == 0 {
						continue
					}
					rcv0 := fd.Recv.List[0]
					rcvty := pc.info.TypeOf(rcv0.Type)
					samety := rcvty == goty
					if ptrty, ok := rcvty.(*types.Pointer); ok && !samety {
						samety = ptrty.Elem() == goty
					}
					if samety {
						this.putFuncCallDependcy(curfd, funame)
					}
				}
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.FuncDecl:
				if te.Recv != nil && te.Recv.NumFields() > 0 {
					curfds = curfds[:len(curfds)-1]
				} else {
					curfds = curfds[:len(curfds)-1]
				}
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}
func (pc *ParserContext) walkpass_func_deps2() {
	nodes := pc.gb.TopologicalSort()
	for _, node := range nodes {
		pc.funcDeclsv = append(pc.funcDeclsv, pc.funcDeclsm[(*node.Value).(string)])
	}
	// unused decls
	for _, d := range pc.funcDeclsm {
		if _, ok := builtinfns[d.Name.Name]; ok {
			continue
		}
		invec := false
		for _, d1 := range pc.funcDeclsv {
			if d1 == d {
				invec = true
				break
			}
		}
		if !invec {
			pc.funcDeclsv = append(pc.funcDeclsv, d)
		}
	}
}

func (pc *ParserContext) walkpass_flat_cursors() {
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			tc := *c
			pc.cursors[c.Node()] = &tc
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}

func (pc *ParserContext) walkpass_tmpl_proc() {
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			tc := *c
			pc.cursors[c.Node()] = &tc
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}

func (pc *ParserContext) walkpass_multiret() {
	multirets := []*ast.FuncDecl{}
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.FuncDecl:
				if te.Type.Results.NumFields() < 2 {
					break
				}
				for idx, fld := range te.Type.Results.List {
					if len(fld.Names) == 0 {
						fld.Names = append(fld.Names, newIdent(tmpvarname2(idx)))
					}
				}
				multirets = append(multirets, te)
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("multirets", len(multirets))
	pc.multirets = multirets
}

// 一句表达不了的表达式临时变量
func (pc *ParserContext) walkpass_tmpvars() {
	pkgs := pc.pkgs
	var tmpvars = map[ast.Stmt][]ast.Node{} // => tmpvarname
	gopp.G_USED(tmpvars)

	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				// log.Println(c.Name(), exprpos(pc, c.Node()))
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.CompositeLit:
				break
				ce := c.Node().(ast.Expr)
				vsp2 := &ast.AssignStmt{}
				vsp2.Lhs = []ast.Expr{newIdent(tmpvarname())}
				vsp2.Rhs = []ast.Expr{ce}
				xe := &ast.UnaryExpr{}
				xe.Op = token.AND
				xe.OpPos = c.Node().Pos()
				xe.X = ce
				vsp2.Rhs = []ast.Expr{xe}
				vsp2.Tok = token.DEFINE
				c.Replace(vsp2.Lhs[0])
				stmt := upfindstmt(pc, c, 0)
				tmpvars[stmt] = append(tmpvars[stmt], vsp2)
				tyval := types.TypeAndValue{}
				tyval.Type = pc.info.TypeOf(ce)
				tyval.Type = types.NewPointer(tyval.Type)
				pc.info.Types[vsp2.Lhs[0]] = tyval
				pc.info.Types[vsp2.Rhs[0]] = tyval
			case *ast.UnaryExpr:
				if te.Op == token.AND {
					if _, ok := te.X.(*ast.CompositeLit); ok {
						vsp2 := &ast.AssignStmt{}
						vsp2.Lhs = []ast.Expr{newIdent(tmpvarname())}
						vsp2.Rhs = []ast.Expr{te}
						vsp2.Tok = token.DEFINE
						vsp2.TokPos = c.Node().Pos()
						c.Replace(vsp2.Lhs[0])
						stmt := upfindstmt(pc, c, 0)
						tmpvars[stmt] = append(tmpvars[stmt], vsp2)
						tyval := types.TypeAndValue{}
						tyval.Type = pc.info.TypeOf(te)
						pc.info.Types[vsp2.Lhs[0]] = tyval
					}
				}
			case *ast.CallExpr:
				for idx, aex := range te.Args {
					switch ae := aex.(type) {
					case *ast.BasicLit:
						vsp2 := &ast.AssignStmt{}
						vsp2.Lhs = []ast.Expr{newIdent(tmpvarname())}
						vsp2.Rhs = []ast.Expr{ae}
						vsp2.Tok = token.DEFINE
						vsp2.TokPos = c.Node().Pos()
						te.Args[idx] = vsp2.Lhs[0]
						// c.Replace(vsp2.Lhs[0])
						stmt := upfindstmt(pc, c, 0)
						tmpvars[stmt] = append(tmpvars[stmt], vsp2)
						tyval := types.TypeAndValue{}
						tyval.Type = pc.info.TypeOf(ae)
						pc.info.Types[vsp2.Lhs[0]] = tyval
					case *ast.CallExpr:
						vsp2 := &ast.AssignStmt{}
						vsp2.Lhs = []ast.Expr{newIdent(tmpvarname())}
						vsp2.Rhs = []ast.Expr{ae}
						vsp2.Tok = token.DEFINE
						vsp2.TokPos = c.Node().Pos()
						te.Args[idx] = vsp2.Lhs[0]
						// c.Replace(vsp2.Lhs[0])
						stmt := upfindstmt(pc, c, 0)
						tmpvars[stmt] = append(tmpvars[stmt], vsp2)
						tyval := types.TypeAndValue{}
						tyval.Type = pc.info.TypeOf(ae)
						pc.info.Types[vsp2.Lhs[0]] = tyval
					default:
						// log.Println(ae, reftyof(ae))
					}
				}
			case *ast.AssignStmt: // processing _ name
				for idx, ae := range te.Lhs {
					aidt, ok := ae.(*ast.Ident)
					if !ok {
						continue
					}
					if aidt.Name == "_" {
						tidt := ast.NewIdent(tmpvarname())
						te.Lhs[idx] = tidt
						tyval := types.TypeAndValue{}
						tyval.Type = pc.info.TypeOf(te.Rhs[idx])
						if tyval.Type == nil {
							tyval.Type = types.Typ[types.Int]
						}
						pc.info.Types[te.Lhs[idx]] = tyval
						pc.info.Types[tidt] = tyval

						// stmt := upfindstmt(pc, c, 0)
						stmt := te
						valsp := &ast.ValueSpec{}
						valsp.Names = []*ast.Ident{tidt}
						valsp.Type = te.Rhs[idx]
						//valsp.Values = []ast.Expr{ast.NewIdent("nilptr")}
						tmpvars[stmt] = append(tmpvars[stmt], valsp)
						pc.cursors[valsp] = c
					}
				}
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("tmpvars", len(tmpvars))
	pc.tmpvars = tmpvars
}

func (pc *ParserContext) walkpass_kvpairs() {
	kvpairs := map[ast.Node]ast.Node{}
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.AssignStmt:
				if len(te.Lhs) > len(te.Rhs) {
					// multirets
					break
				}
				for idx, le := range te.Lhs {
					kvpairs[le] = te.Rhs[idx]
					kvpairs[te.Rhs[idx]] = le
				}
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("kvpairs", len(kvpairs))
	pc.kvpairs = kvpairs
}

func (pc *ParserContext) walkpass_functypes() {
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case ast.Expr:
				switch ye := te.(type) {
				case *ast.FuncType:
					pn := c.Parent()
					if _, ok := pn.(*ast.FuncDecl); ok {
						break
					}
					log.Println(te, exprstr(te), reftyof(te), reftyof(pn), ye)
					pc.functypes[ye] = tmptyname()
				}

			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}

func (pc *ParserContext) walkpass_gostmt() {
	var gostmts = []*ast.GoStmt{}
	_ = gostmts

	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.GoStmt:
				gostmts = append(gostmts, te)
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("gostmts", len(gostmts))
	pc.gostmts = gostmts
}

func (pc *ParserContext) walkpass_chan_send_recv() {
	var chanops = []ast.Expr{}
	_ = chanops

	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.SendStmt:
				chanops = append(chanops, te.Chan)
			case *ast.UnaryExpr:
				if te.Op == token.ARROW {
					chanops = append(chanops, te.X)
				}
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("chanops", len(chanops))
	pc.chanops = chanops
}

func (pc *ParserContext) walkpass_closures() {
	var closures = []*ast.FuncLit{}
	_ = closures

	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.FuncLit:
				closures = append(closures, te)
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("closures", len(closures))
	pc.closures = closures
}

// 删除一些调用go tool cgo命令时生成的不需要的符号
func (pc *ParserContext) walkpass_clean_cgodecl() {
	pkgs := pc.pkgs
	skipfds := []string{"_cgo_runtime_cgocallback", "_cgoCheckResult", "_cgoCheckPointer",
		"_Cgo_use", "_cgo_runtime_cgocall", "_Cgo_ptr", "_cgo_cmalloc", "runtime_throw",
		"_cgo_runtime_gostringn", "_cgo_runtime_gostring"}

	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {

			switch te := c.Node().(type) {
			case *ast.FuncDecl:

				if funk.Contains(skipfds, te.Name.Name) {
					c.Delete()
				}
			case *ast.ValueSpec:
				name := te.Names[0].Name
				if strings.HasPrefix(name, "__cgofn__cgo_") || strings.HasPrefix(name, "_cgo_") ||
					strings.HasPrefix(name, "_Ciconst_") || strings.HasPrefix(name, "_Cfpvar_") {
					c.Delete()
					break
				}
				tystr := types.ExprString(te.Type)
				if tystr == "syscall.Errno" || te.Names[0].Name == "_" {
					c.Delete()
					break
				}
			case *ast.CallExpr:
				if fe, ok := te.Fun.(*ast.Ident); ok {
					if fe.Name == "_Cgo_ptr" {
						c.Replace(newIdent(te.Args[0].(*ast.Ident).Name[11:]))
						break
					}
					if fe.Name == "_cgoCheckPointer" {
						// panic: Delete node not contained in slice
						// c.Delete()
						// break
					}
				}
			case *ast.Ident:
				if strings.HasPrefix(te.Name, "_Ciconst_") {
					c.Replace(newIdent(te.Name[9:]))
				}
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
}

// todo
func (pc *ParserContext) walkpass_nested_func() {
}

// todo
func (pc *ParserContext) walkpass_nested_type() {
}

func (pc *ParserContext) walkpass_defers() {
	defers := []*ast.DeferStmt{}

	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.DeferStmt:
				defers = append(defers, te)
			case *ast.FuncDecl:
				if te.Type.Results.NumFields() == 0 {
					// if len(te.Body.List) == 0 {
					// 	retstmt := &ast.ReturnStmt{}
					// 	retstmt.Results = []ast.Expr{}
					// 	// retstmt.Return = te.Pos()
					// 	te.Body.List = append(te.Body.List, retstmt)
					// } else {
					// 	log.Println("hhh")
					// 	laststmt := te.Body.List[len(te.Body.List)-1]
					// 	log.Println(laststmt)
					// }
				}
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("defers", len(defers))
	pc.defers = defers
}

func (pc *ParserContext) walkpass_globvars() {
	globvars := []ast.Node{}
	pkgs := pc.pkgs
	for _, pkg := range pkgs {
		astutil.Apply(pkg, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			case *ast.ValueSpec:
				for _, name := range te.Names {
					if isglobalid(pc, name) {
						globvars = append(globvars, te)
					}
				}
			default:
				gopp.G_USED(te)
			}
			return true
		}, func(c *astutil.Cursor) bool {
			switch te := c.Node().(type) {
			default:
				gopp.G_USED(te)
			}
			return true
		})
	}
	log.Println("globvars", len(globvars))
	pc.globvars = globvars
}

func (pc *ParserContext) putTyperefDependcy(funame, tyname string) {

}

// name0: caller
// name1: callee
func (pc *ParserContext) putFuncCallDependcy(name0, name1 string) {
	if name0 == name1 {
		return
	}
	if _, ok := builtinfns[name1]; ok {
		return
	}
	n0, ok0 := pc.funcdeclNodes[name0]
	if !ok0 {
		n0 = pc.gb.MakeNode()
		*n0.Value = name0
		pc.funcdeclNodes[name0] = n0
	}
	n1, ok1 := pc.funcdeclNodes[name1]
	if !ok1 {
		n1 = pc.gb.MakeNode()
		*n1.Value = name1
		pc.funcdeclNodes[name1] = n1
	}
	// log.Println("adding", name0, n0.Value, "->", name1, n1.Value)
	err := pc.gb.MakeEdge(n1, n0)
	gopp.ErrPrint(err, name0, name1)
}

func (pc *ParserContext) getImportNameMap() map[string]string {
	pkgrenames := map[string]string{} // path => rename
	for pname, pkgo := range pc.pkgs {
		log.Println(pname, pkgo.Name, pkgo.Imports)
		for fname, fileo := range pkgo.Files {
			log.Println(fname, fileo.Imports)
			for _, declo := range fileo.Decls {
				ad, ok := declo.(*ast.GenDecl)
				if !ok {
					continue
				}
				for _, tspec := range ad.Specs {
					id, ok := tspec.(*ast.ImportSpec)
					if ok {
						log.Println(id.Name, id.Path)
						dirp := strings.Trim(id.Path.Value, "\"")
						if id.Name != nil {
							pkgrenames[dirp] = id.Name.Name
						} else {
							pkgrenames[dirp] = ""
						}
					}
				}
			}
		}
	}
	return pkgrenames
}
